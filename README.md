Аутентификация

При входе пользователя в систему ему выдаются временные access и refresh токены.
Срок жизни, как и секретный код для генерации токенов хранится в переменных окружения (тут он просто прописан как дефолт в core/config).
В токене зашифрованы такие параметры как время жизни, тип токена (access/refresh) и id сессии.

Так как access токен открывает доступ ко всем данным, срок его жизни желательно выставить небольшой (15 минут).
Refresh токен же, служит долгосрочным доступом к аккаунту. С его помощью можно обновить access токен через метод auth/refresh.
Его срок жизни желательно выставить большим (1 месяц). Из недостатков данной реализации, можно было бы сделать опцию продлевания refresh токена для того, чтобы сессия пользователя не сбрасывалась по истечении времени.
Срок жизни refresh токена и есть срок жизни сессии. В случае, если пользователь не выходя из сессии (auth/logout) снова произведет вход (auth/login), то старая сессия пользователя закроется автоматически,
и откроется новая. 
В данной реализации учтена возможность работы с разных устройств, (десктоп и телефон имеют разные сессии и могут работать параллельно, но для одного типа устройства - только одна сессия).


Токены хранятся на клиенте и отправляются в том случае, если приходит 401 код (кончился access).


Была идея помещать permissions (Разрешения: user:get_all) прямо в токен, но тогда, в случае, если пользователю выдается новая роль, или роль изменяют добавляя/удаляя разрешения, пришлось бы закрывать сессии всем пользователям, либо как-то обновлять токен на клиенте, что не очень удобно, поэтому из токена мы узнаем user_id и по нему уже проверяем разрешения в БД.

Как отозвать токены конкретного пользователя, например в случае кражи. Если пользователь выйдет из аккаунта, он автоматически уничтожит креды, так как они принадлежат конкретной сессии, а она закрылась.
Не зная refresh токена, у злоумышленника будет 15 минут (срок access) для получения доступа к данным.

Можно отозвать все токены разом, поменяв секрет.


Идейно существуют разные роли у одного пользователя может быть несколько ролей, у каждой роли свои разрешения. 
Например user:get базовое разрешение на получение собственного аккаунта. Тем временем user:get_all - разрешение для админа, получать разные пользователей по запросу.
Формат записи следующий {сущность_или_действие:метод}, для метода выдачи ролей пользователям тяжело назвать с какой сущности отнести это, поэтому указывается действие, а как метод start.
add_roles:start.

На самом деле неважно, что будет написано внутри, это всего лишь согласованность для удобства, так как, в любом случае на горячую это поменять проблематично, ведь требуемые разрешения прописаны в коде в зависимостях.

Соответственно роль админа - должна совмещать в себе все доступные разрешения.

Подробнее с существующими методами можно ознакомиться в swagger (/docs)

Предварительная заготовка данных

База поднимается в Docker для удобства развертки, при первом создании проинициализирует таблицы. Также для удобства в базе создается аккаунт с admin ролью. и несколько разрешений и ролей, а также связи между ними.

Ps* работа была достаточно объемная и в силу нехватки свободного времени не был реализован весь функционал, возможно какие-то методы для работы admin.